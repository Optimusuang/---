深入了解Browser Storage 
前言
随着移动网络的发展与演化，我们手机上现在除了原生App，还能跑“WebApp"--它即开即用，用完即走。一个优秀的webapp甚至可以拥有和原生App媲美的功能和体验。webapp优异性能的表现有一部分要归功于browser存储技术的提升。cookie存储数据的功能已经很难满足开发者所需，逐渐被WebStorage,IndexedDB所取代，本文将介绍这几种存储方式的差异和优缺点。
  一、Cookie
1、Cookie的来源
     Cookie的本职工作并非本地存储，而是”维持状态“。因为HTTP协议是无状态的，HTTP协议自身不对请求和响应之间的通信状态进行保存，通俗来说，服务器不知道用户上一次做了什么，这严重阻碍了交互式web应用程序的实现。在典型的网上购物场景中，用户浏览了几个页面，买了一盒饼干和两瓶饮料，结账时由于HTTP的无状态性，不通过额外的手段，服务器并不知道用户到底买了什么，于是就诞生了Cookie.它就是用来绕开HTTP的无状态性的“额外手段”之一。服务器可以设置或读取Cookie在包含的信息，借此维护用户跟服务器会话中的状态。
       我们可以把Cookie理解为一个存储在浏览器的一个小小的文本文件，它附着在HTTP请求上，在浏览器和服务器之间飞来飞去。它可以携带用户信息，当服务器检查Cookie的时候，便可以获取到客户端的状态 。
        在刚才的购物场景在中，当用户选购了第一项商品，服务器在向用户发送网页的同时，还发送了一段Cookie，记录着那项商品的信息。当用户访问另一个页面，浏览器会把Cookie发送给服务器，于是服务器知道他之前选购了什么。用户继续选购饮料，服务器就在原来那段Cookie里追加新的商品信息。结账时，服务器读取发送来的Cookie就行了。
2.什么是Cookie及应用场景
      Cookie指某些网站为了辨别用户身份而存储在用户本地终端上的数据（通常经过加密）。cookie是服务端生成，客户端进行维护和存储。通过cookie，可以让服务器知道请求是来源哪个客户端，就可以进行客户端状态的维护，比如登陆后刷新，请求头就会携带登陆时respone header中的set-cookie,Web服务器接收到请求时也能读出cookie的值，根据cookie值的内容就可以判断和恢复一些用户的信息状态。

如上图所示，Cookie以键值的形式存在。
典型的应用场景有：
*记住密码，下次自动登录
*购物车功能
*记录用户浏览数据，进行商品，广告推荐。
3.Cookie的原理及生成方式
Cookie的原理

第一次访问网站的时候，浏览器发出请求，服务器响应请求后，会在响应头里面添加一个Set-Cookie选项，将Cookie放入到响应请求中，在浏览器第二次发请求的时候，会通过Cookie请求头部将Cookie的过期时间，域，路径，，有效期，适用站点都可以根据需要来指定。
Cookie的生成方式主要有两种：
*生成方式一：http response header中的set-cookie
我们可以通过响应头里的Set-Cookie指定要存储的Cookie值。默认情况下，domain被设置为Cookie页面的主机名，我们也可以手动设置domin的值。

当Cookie的过期时间被设定时，设定的日期和时间只与客户有关，而不是服务端。
*生成方式二：js中可以通过document.cookie可以读写cookie，以键值对的形式展示
4.Cookie的缺陷
*Cookie不够大
Cookie的大小限制在4KB左右，对于复杂的存储来说是不够用的。当Cookie超过4KB时，它将面临被裁切的命运。这样看来，Cookie只能用来存取少量的信息。此外很多浏览器一个站点的Cookie个数也是有限制的。
这里需要注意：各浏览器的Cookie每一个name=value的value值大概在4k，所以4k并不是一个域名下的所有的Cookie共享的，而是一个name的大小。
*过多的Cookie会带来巨大的性能浪费
Cookie是紧跟域名的。同一个域名下的所有请求，都会携带Cookie，。大家试想，如果我们此刻仅仅是请求一张图片或者一个CSS文件，我们也要携带一个Cookie跑来跑去（关键是Cookie里存储的信息并不需要），这是一件多么劳民伤财的事情。Cookie虽小，请求却可以有很多，随着请求的增加，这样的不必要的Cookie带来的开销将是无法想象的。
cookie是用来维护用户信息的，而域名（domain）下所有请求都会携带cookie，但对于静态文件的请求，携带cookie信息根本没有用，此时可以通过cdn(存储静态文件的)的域名和主站的域名分开来解决。
*用于在HTTP请求中的Cookie是明文传递的，所以安全性成问题，除非用HTTPS。
5.Cookie与安全


HttpOnly不支持读写，浏览器不允许脚本操作document.cookie去更改cookie,所以为了避免跨域脚本（XSS）攻击，通过Javascript的Document.cookie API无法访问带有 HttpOnly标记的Cookie,它们只应该发送给服务端。如果包含服务端Session信息的Cookie不想被客户端Javascript脚本调用，那么就应该为其设置HttpOnly标记。

标记为 Secure 的Cookie只应通过被HTTP协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过Cookie传输，因为Cookie有其固有的不安全性，Secure 标记也无法提供确实的安全保障。
为了弥补Cookie的局限性，让“专业的人做专业的事情”，Wsb Storage 出现了。
HTML5中新增了本地存储的解决方案——Web Storage,它分成两类：sessionStorage和localStorage.这样有了WebStorage后，cookie能只做它应该做的事情了——作为客户端与服务器交互的通道，保持客户端状态。
二.LocalStorage
1.LocalStorage的特点
*保存的数据长期存在，下一次访问该网站的时候，网页可以直接读取以前保存的数据
*大小为5M左右
*仅在客户端使用，不和服务端通信
*接口封装较好
基于上面的特点，LocalStorage可以作为浏览器本地缓存方案，用来提升网页首屏渲染速度（根据第一请求返回时，将一些不变信息储在本地）。
2.存入/读取数据
LocalStorage 保存的数据，以“键值对”的形式存在。也就是说，每一项数据都有一个键名和对应的值.所有的数据都是以文本格式保存。存入数据使用setltem方法。它接受两个参数，第一个是键名，第二个是保存的数据。Localstorage.setItem( "key" , "value" );读取数据使用getltem方法。它只有一个参数，就是键名。 Var valueLocal=localStorage.getItem( "key" );
具体步骤如下例：

3.使用场景
LocalStorage在存储方面没有什么特别的限制，理论上 Cookie 无法胜任的，可以用简单的键值对来存取的数据存储任务，都可以交给LocalStorage来做。
例如，考虑到 LocalStorage 的特点之一是持久，于是我们更倾向于用它来存储一些内容稳定的资源。比如图片内容丰富的电商网站会用它来存储 Base64 格式的图片字符串：

三.sessionStorage
sessionStorage保存的数据用于浏览器的一次对话，当会话结束（通常是该窗口关闭），数据被清空；sessionStorage 特别的一点在于，即便是相同域名下的两个页面，只要它们不在同一个浏览器窗口中打开，那么它们的sessionStorage内容便无法共享；localStoragez在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。除了保存期限的长短不同，SessionStorage的属性和方法与LocalStorage完全一样。
1.sessionStorage的特点
*会话级别的浏览器存储
*大小为5M左右
*仅在客户端使用，不和服务端进行通信
*接口封装好
基于上面的特点，sessionStorage可以有效对表单信息进行维护，比如刷新时，表单信息不丢失。
2.使用场景
sessionStorage更适合用来存储生命周期和它听不懂会话级别的 信息。这些信息只适用于当前会话，当你开启新的会话时，它也需要相应的更新或释放。比如微博的sessionStorage就主要是存储你本次会话的浏览足迹：

lasturl对应的就是你上一次访问的URL地址，这个地址时即时的。当你切换URL时，它随之更新，当你关闭页面时，留着它也确实没有什么意义了，干脆释放吧。这样的数据用sessionStorege来处理再合适不过。
3.sessionStorage,localStorage和cookie之间的区别
*共同点：都是保存在浏览器端，且都遵循同源策略。
*不同点：在于生命周期与作用域的不同
作用域：localStorage只要在相同的协议，相同的主机名，相同的端口下，就能读取/修改到同一份localStorage数据。sessionStorage比localStorage更苛刻一点，除了协议，主机名，端口外，还要求在同一窗口（也就是浏览器的标签页）下

生命周期：localStorage时持久化的本地存储，存储在其中的数据是永远不会过期的，使其消失的唯一办法是手动删除；而sessionStorage是临时性的本地存储，它是会话级别的存储，当会话结束（页面被关闭）时，存储内容也随之被释放。
WebStorage是一个从定义到使用都非常简单的东西。它使用键值对的形式进行存储，这种模式有点类似于对象，却甚至连对象都不是——它只能存储字符串，要想得到对象，我们还需要先对字符串进行一轮解析。说到底，web Storage是对Cookie的拓展，它只能用于存储少量的简单数据，当遇到大规模的，结构复杂的数据时，WebStorage也爱莫能助，这时候我们就要清楚我们的终极大boss——IndexedDB！
四.IndexedDB
IndexedDB是一种低级API，用于客户端存储大量结构化数据（包括文件和blobs）。该API使用索引来实现对该数据的高性能搜索。IndexedDB是一个运行在浏览器上的非关系型数据库。既然是数据库那就不是5M,10M小级别了。理论上来说，IndexedDB是没有存储上限的（一般不会小于250M）.它不仅可以存储字符串，还可以存储二进制数据。
1.IndexedDB的特点
• 键值对存储
IndexedDB内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括Javascript对象。对象仓库中，数据以“键值对”的形式保存，每一个数据记录都有对应的主键，主键是独一无二的。
• 异步
IndexedDB操作时不会锁死浏览器，用户依然可以进行其他操作，这与LocalStorage形成对比，后者的操作是同步的。异步设计是为了防止大量的数据的读写，拖慢网页的表现。
• 支持事务
IndexedDB支持事务（transaction），这意味着一系列操作步骤之中，只要一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。
• 同源限制
IndexedDB受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。
• 存储空间大
IndexedDB的存储空间比LocalStorage大得多，不少于250M,甚至没有上限。
• 支持二进制储存
IndexedDB不仅可以储存字符串，还可以储存二进制数据（ArrayBuff）对象和Blob对象。
2.IndexedDB的常见操作
在IndexedDB大部分操作并不是我们常用的调试方法，返回结果的模式，而是请求——响应的模式。
	• 建立打开IndexedDB——window.indexedDB.open("testDB")
这条指令并不会返回一个DB对象的句柄，我们得到的是一个IDBOpenDBRequest对象，而我们希望得到的DB对象在其result属性中

除了result,IDBOpenDBRequest接口定义了几个重要属性：
onerror:请求失败的回调函数句柄
onsuccess :请求成功的回调函数句柄
onupgradeneeded:请求数据库版本变化句柄

控制台得到一个IDBDatabase对象，这就是IndexedDB对象

关闭IndexedDB——indexdb.close()

删除IndexedDB——window.indexedDB.deleteDatabase(indexdb)

3.WebStorage,cookie和IndexedDB之间的区别

cookie已经不建议用于存储，如果没有大量数据库存储需求的话，可以使用localSTorage和sessionStorage。对于不怎么改变的数据尽量使用localStorage存储，否则可以用sessionStorage存储。
总结
正是浏览器存储，缓存技术的出现和发展，为我们的前端应用带来了无限转机。近年来基于存储，缓存技术的第三方库层出不绝，此外还衍生出了PWA这样优秀的Web应用模型。总结下本文几个核心观点：
• Cookie的本职工作并非本地存储，而是”维持状态“
• Web Storage是HTML5专门为浏览器存储而提供的数据库存储机制，不与服务器发生通信
• IndexedDB用于客户端存储大量结构化数据


