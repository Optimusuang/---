https://www.cnblogs.com/xuewangkai/p/11152377.html
  
  LocateElem(L,e)   :按值查找
  ListInsert(&L,i,e):在表L中第i个位置插入指定元素e  
  
  传值   
  是把实参的值赋值给行参   
  那么对行参的修改，不会影响实参的值   
    
  传地址   
  是传值的一种特殊方式，只是他传递的是地址，不是普通的如int   
  那么传地址以后，实参和行参都指向同一个对象   
    
  传引用   
  真正的以地址的方式传递参数   
  传递以后，行参和实参都是同一个对象，只是他们名字不同而已   
  对行参的修改将影响实参的值

-----------------------------------------------------------------------------------

觉得从函数调用的角度理解比较好   
    
  传值：   
  函数参数压栈的是参数的副本。   
  任何的修改是在副本上作用，没有作用在原来的变量上。   
    
  传指针：   
  压栈的是指针变量的副本。   
  当你对指针解指针操作时，其值是指向原来的那个变量，所以对原来变量操作。   
    
  传引用：   
  压栈的是引用的副本。由于引用是指向某个变量的，对引用的操作其实就是对他指向的变量的操作。（作用和传指针一样，只是引用少了解指针的草纸）  

-----------------------------------------------------------------------------------
  函数参数传递机制的基本理论   
  　　函数参数传递机制问题在本质上是调用函数（过程）和被调用函数（过程）在调用发生时进行通信的方法问题。基本的参数传递机制有两种：值传递和引用传递。以下讨论称调用其他函数的函数为主调函数，被调用的函数为被调函数。   
  　　值传递（passl-by-value）过程中，被调函数的形式参数作为被调函数的局部变量处理，即在堆栈中开辟了内存空间以存放由主调函数放进来的实参的值，从而成为了实参的一个副本。值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。   
  　　引用传递(pass-by-reference)过程中，被调函数的形式参数虽然也作为局部变量在堆栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过堆栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的   
  实参变量。   


-----------------------------------------------------------------------------------

  仅讨论一下值传递和引用传递：   
  所谓值传递，就是说仅将对象的值传递给目标对象，就相当于copy；系统将为目标对象重新开辟一个完全相同的内存空间。   
  所谓引用，就是说将对象在内存中的地址传递给目标对象，就相当于使目标对象和原始对象对应同一个内存存储空间。此时，如果对目标对象进行修改，内存中的数据也会改变。
